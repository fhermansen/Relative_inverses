/-
Copyright (c) 2022 Flemming Hermansen. 
Released under Apache 2.0 license as described in 
https://www.apache.org/licenses/LICENSE-2.0
Authors: Flemming Hermansen
-/

import tactic
import tactic.basic
import field_theory.separable

import boolean_algebra_of_comm_ring_idempotents
import strict_mono_seq
import rel_inv

/-
lemma ideal_of_idempotent_strictly_increasing {A : Type*} [comm_ring A] 
{e' e : idempotent_cri A} (hlt : e' < e)
: (ideal.span {e'.val} : ideal A) < (ideal.span {e.val} : ideal A) 

theorem maxideal_from_atom' {A : Type*} [comm_ring A] {e a : A} 
(hcov : covers_0 e) (h_inv : all_rel_inv A) (hnI : a * (1-e) ≠ a)
: ∃ b, b * a = e :=
-- Given a commutative ring A in which all elements have relative inverses,
-- and given an atom e. 
-- Let a be an element outside the ideal generated by the complement of e. 
-- Then there exists an element b such that a*b=e. 
-- It follows that if the ideal is expanded by any element then it contains e
-- and thus 1. 
-- In other words: an ideal generated by a coatom is a maximal ideal:

lemma maxideal_from_atom {A : Type*} [comm_ring A] {e x: A} 
(hcov : covers_0 e) (h_inv : all_rel_inv A)  : 
(ideal.span {1 - e} : ideal A).is_maximal 
An ideal generated from a coatom is maximal.

theorem no_strict_mono_to_ideals_from_finite_dimensional (K : Type*) 
[hK : field K] {A : Type*} 
  [h_comm_A : comm_ring A] [h_alg : algebra K A] (h_fin : finite_dimensional K A) :
( ¬( ∃ (strict_mono_seq : ℕ → ideal A), strict_mono strict_mono_seq ) ) 
-- When the K-algebra is finite dimensional then there does not exist
-- a strictly increasing sequence of ideals.

-- The first main theorem states that a finite dimensional algebra has a 
-- finite set of atoms with sup = ⊤:
theorem ex_fin_atomset_of_finite_dimensional (K : Type*) 
[hK : field K] {A : Type*} 
  [h_comm_A : comm_ring A] [h_alg : algebra K A] (h_fin : finite_dimensional K A) : 
∃ (s : finset (idempotent_cri A)), (∀ e ∈ s, ⊥ ⋖ e) ∧ boolean_algebra_finset_sup s = ⊤ 

The second main theorem states that if e is an atom then e is the one-element in the ideal,
and each non-zero element in the ideal has an inverse within the ideal. 
This means that an ideal generated by an atom is a field.
lemma field_from_atom {A : Type*} [hA : comm_ring A]  (h_inv : all_rel_inv A)
{e a : A} (hnz_a : a ≠ 0) (hcov : covers_0 e) (ha_in_span : a ∈ ((ideal.span {e} : ideal A)) ) : 
a * e = a ∧ 
( ∃ (b : A), b ∈ ((ideal.span {e} : ideal A)) ∧ a * b = e)

-/

-------------------------------
-- Conversion from a strictly increasing sequence of ideals 
-- to a strictly increasing sequence of submodules over the scalar field

def submodule_KA_of_AA_smul {K : Type*} [hK : field K] {A : Type*} 
  [hA : comm_ring A] [hKA : algebra K A] (submod_AA : submodule A A) 
  {k : K} {a : A} (h_sm_a : a ∈ submod_AA.carrier) : 
  (((algebra.to_ring_hom k) : A) * a) ∈ submod_AA.carrier := 
  begin
    have h : ∀ (aa : A), aa * a ∈ submod_AA.carrier, 
    begin
      intros aa, exact submod_AA.smul_mem' aa h_sm_a,
    end,
    exact h (algebra.to_ring_hom k),
end

def submodule_KA_of_AA {K : Type*} [hK : field K] {A : Type*} 
  [hA : comm_ring A] (hKA : algebra K A) (submod_AA : submodule A A) : 
  submodule K A := 
  begin
    have add_mem' : ∀ (a b : A), a ∈ submod_AA.carrier → 
    b ∈ submod_AA.carrier → a + b ∈ submod_AA.carrier,
    begin
      intros a b ha hb,
      exact submod_AA.add_mem' ha hb,
    end,
    have smul' : ∀ (k : K) (a : A), a ∈ submod_AA.carrier → 
    (((algebra.to_ring_hom k) : A) * a) ∈ submod_AA.carrier,
    begin
       intros k a,
       exact submodule_KA_of_AA_smul submod_AA,
    end,
     have smul'' : ∀ (k : K) (a : A), a ∈ submod_AA.carrier → 
    (k • a) ∈ submod_AA.carrier,
    begin
       intros k a h0,
       rw algebra.smul_def',
       exact smul' k a h0,
    end,
    exact { carrier := submod_AA.carrier,
      add_mem' := add_mem',
      zero_mem' := submod_AA.zero_mem',
      smul_mem' := smul'' },
end

lemma submodule_AA_lt_of_subset {K : Type*} [hK : field K] {A : Type*} 
  [hA : comm_ring A] (hKA : algebra K A) {A1 A2 : submodule A A} 
    : A1 < A2 ↔ submodule.carrier A1 ⊂ A2.carrier :=
  begin
    exact set_like.coe_ssubset_coe,
  end

lemma submodule_KA_lt_of_subset {K : Type*} [hK : field K] {A : Type*} 
  [hA : comm_ring A] (hKA : algebra K A) {A1 A2 : submodule K A} 
    : submodule.carrier A1 ⊂ A2.carrier → A1 < A2 :=
  begin
    rw ← set_like.coe_ssubset_coe, intros h, exact h,
  end

lemma eq_carrier {K : Type*} [hK : field K] {A : Type*} 
  [hA : comm_ring A] (hKA : algebra K A) (submod_AA : submodule A A) :
  submod_AA.carrier = (submodule_KA_of_AA hKA submod_AA).carrier :=
  begin
    let g := submod_AA.carrier,
    let gg := (submodule_KA_of_AA hKA submod_AA).carrier,
    --simp at gg {proj := true},
    unfold submodule_KA_of_AA,
  end

lemma submodule_KA_lt_of_ideal_lt {K : Type*} [hK : field K] {A : Type*} 
  [hA : comm_ring A] (hKA : algebra K A) {A1 A2 : submodule A A} 
    : A1 < A2 → (submodule_KA_of_AA hKA A1) < (submodule_KA_of_AA hKA A2) :=
  begin
    intros hA1_lt_A2,
    let ss_A1_A2 := (submodule_AA_lt_of_subset hKA).1 hA1_lt_A2,
    rw eq_carrier hKA at ss_A1_A2, rw eq_carrier hKA at ss_A1_A2,
    exact (submodule_KA_lt_of_subset hKA ss_A1_A2) ,
  end

def submodule_seq_KA_lt_of_ideal_lt {K : Type*} [hK : field K] {A : Type*} 
  [hA : comm_ring A] [hKA : algebra K A] (f : ℕ → ideal A) :  ℕ → submodule K A :=
begin
  intros n,
  exact submodule_KA_of_AA hKA (f n),
end

/-
The following lemma says that a strictly increasing sequence of ideals
is also a strictly increasing sequence of submodules over the scalar field.
-/
lemma ex_strict_mono_submodule_of_ideal {K : Type*} [hK : field K] {A : Type*} 
  [hA : comm_ring A] [hKA : algebra K A] (f : ℕ → ideal A) (f_strict_mono : strict_mono f): 
  ∃ (g : ℕ → submodule K A), strict_mono g := 
  begin
    unfold strict_mono at *,
    use submodule_seq_KA_lt_of_ideal_lt f,
    intros n1 n2 h_lt,
    unfold submodule_seq_KA_lt_of_ideal_lt,
    apply submodule_KA_lt_of_ideal_lt,
    exact f_strict_mono h_lt,
end

----------------------------

section inv_a

variables {K : Type*} [field K] {A : Type*} 
  [comm_ring A] [algebra K A] {a : A} -- {he : e * e = e} 
  [finite_dimensional K A] [is_separable K A]
  (P : polynomial K)

-----
variables {B : Type*} -- (idempotent_cri A)

def ortho_e [comm_ring A] (e1 e2 : (idempotent_cri A)): Prop := e1 ⊓ e2 = ⊥

def nz_e (e:idempotent_cri A) := ⊥ < e
def idem_e (a : A) := a * a = a
def ortho_s (s:finset (idempotent_cri A)) := ∀ (e e' ∈ s), e ≠ e' → ortho_e e e'
def atom_s (s:finset (idempotent_cri A)) := ∀ (e ∈ s), ⊥ ⋖ e
def nz_s (s:finset (idempotent_cri A)) := ∀ (e ∈ s), nz_e e
--------------------------------

open_locale classical
open_locale big_operators
noncomputable theory

---------------------------------------------------------
def covers_0 (e : A) : Prop := e ≠ 0 ∧ e * e = e ∧ 
∀ (e' : A), e' * e' = e' → e' * e = e' → (e' = 0 ∨ e' = e)


theorem maxideal_from_atom' {A : Type*} [comm_ring A] {e a : A} 
(hcov : covers_0 e) (h_inv : all_rel_inv A) (hnI : a * (1-e) ≠ a)
: ∃ b, b * a = e :=
begin
-- Given a commutative ring A in which all elements have relative inverses,
-- and given an atom e. 
-- Let a be an element outside the ideal generated by the complement of e. 
-- Then there exists an element b such that a*b=e. 
-- It follows that if the ideal is expanded by any element then it contains e
-- and thus 1. 
-- In other words: an ideal generated by a coatom is a maximal ideal.

  unfold all_rel_inv at h_inv,
  cases hcov with he_nz h, cases h with he_idem he'_covby_e,
  have hae_nz : a * e ≠ 0,
  begin
    by_contradiction hae0,
    have kk : a * (1 - e) = a,
    begin
      calc a * (1 - e) = a - (a * e) : by ring
      ... = a - 0 : by rw hae0
      ... = a : by ring,
    end,
    contradiction,
  end,
  specialize h_inv (a * e), cases h_inv with b h_rel_inv,
  unfold is_rel_inv at h_rel_inv,
  cases h_rel_inv with he h_rel_inv, cases h_rel_inv with ha hb,
  specialize he'_covby_e (a * e * b), 
  have he'_le_e : a * e * b * e = a * e * b,
  begin
    calc a * e * b * e = a * (e * e) * b : by ring
    ... = a * e * b : by rw he_idem,
  end,
  have hae_0_or_e : a * e * b = 0 ∨ a * e * b = e,
  begin 
    exact he'_covby_e he he'_le_e,
  end,
  have haeb_nz : a * e * b ≠ 0,
  begin
    by_contradiction haeb0,
    rw haeb0 at ha, simp at ha, rw ← ha at hae_nz, 
    contradiction,
  end,
  use e * b,
  have haeb_nz' : (e * b) * a = a * e * b, by ring,
  cases hae_0_or_e, 
  contradiction, 
  rw hae_0_or_e at haeb_nz', exact haeb_nz',
end

lemma orthog_not_dvd {A : Type*} [comm_ring A] {e e': A} 
(h_idem : idem_e e) (h_nz : e ≠ 0) (h_orthog : e' * e = 0) 
: ¬ e' ∣ e + e' :=
begin
  unfold has_dvd.dvd, push_neg, intros c,
  by_contradiction, unfold idem_e at  h_idem,
  have h_contra : c * 0 = e,
  begin
    rw ← h_orthog, rw ← mul_assoc, conv {to_lhs, congr, rw mul_comm,}, rw ← h,
    rw right_distrib, rw h_orthog, rw h_idem, ring,
  end,
  simp at h_contra, rw ← h_contra at h_nz, contradiction,
end

lemma ideal_orthog_not_mem {A : Type*} [comm_ring A] {e e': A} 
(h_idem : idem_e e) (h_nz : e' ≠ 0) (h_orthog : e' * e = 0) 
: e' ∉ (ideal.span {e} : ideal A) :=
begin
  have h_no_aee' : ¬ ∃ (a : A), a * e = e',
  begin
    by_contradiction haee',
    cases haee' with a haee',
    have he'0 : e' = 0,
    begin
      unfold idem_e at h_idem,
      rw ← haee',
      rw ← h_idem,
      rw ← mul_assoc, rw haee', assumption,
    end,
    contradiction,
  end,
  unfold ideal.span,
  rw submodule.mem_span_singleton, exact h_no_aee',
end

lemma ideal_gt_of_orthog_sum {A : Type*} [comm_ring A] {e' f : A} 
(h_idem_e' : e' * e' = e') (h_idem_f : f * f = f)
(h_lt : e' * f = e') (h_ne : e' ≠ f)  
: (ideal.span {e'} : ideal A) < (ideal.span {f} : ideal A) :=
begin
  --unfold idem_e at h_idem_e',
  -- First prove that (ideal.span {e'} : ideal A) ≤ (ideal.span {f}) 
  have hdvd : f ∣ e',
  begin 
    unfold has_dvd.dvd, use e', rw mul_comm, rw h_lt,
  end,
  have ideal_e'_le_ideal_epe'_iff_epe'_dvd_e' : 
  (ideal.span {e'} : ideal A) ≤ ideal.span {f} ↔ f ∣ e',
  begin 
    exact ideal.span_singleton_le_span_singleton,
  end,
  have ideal_e'_le_ideal_e_e' : (ideal.span {e'} : ideal A) ≤ (ideal.span {f}) ,
  begin
    rw ideal.span_singleton_le_span_singleton, exact hdvd,
  end,
  -- Next, prove ¬ (ideal.span {e + e'}) ≤ (ideal.span {e'} : ideal A)
  have not_dvd : ¬ e' ∣ f, 
  begin
    unfold has_dvd.dvd, push_neg,
    intros c,
    by_contradiction,
    have h_contra : f = e',
    begin
      rw [h, ← h_idem_e', mul_assoc, ← h, h_lt, h_idem_e'],
    end,
    rw h_contra at h_ne,
    contradiction,
  end,
  have ideal_epe'_le_ideal_e'_iff_e'_dvd_epe' : 
  (ideal.span {f} : ideal A) ≤ ideal.span {e'} ↔ e' ∣ f,
  begin 
    exact ideal.span_singleton_le_span_singleton,
  end,
  rw ← ideal_epe'_le_ideal_e'_iff_e'_dvd_epe' at not_dvd,
    -- ¬ideal.span {e + e'} ≤ ideal.span {e'}
  rw preorder.lt_iff_le_not_le,
   exact and.intro ideal_e'_le_ideal_e_e' not_dvd,
end

section convert_cri

open idempotent_cri

lemma eq_bot_iff_val_eq_cri {A : Type*} [comm_ring A] 
{e : idempotent_cri A} : ( e = (⊥ : idempotent_cri A) ) ↔ ↑e = (0:A) :=
begin
  split,
  -- ->
  intros hz,
  let gg := congr_arg subtype.val hz, -- e.val = ⊥.val
  exact gg,
  -- <-
  intros hz,
  -- exact subtype.eq hz,
  apply subtype.eq,
  exact hz,
end

lemma eq_iff_val_eq_cri {A : Type*} [comm_ring A] 
(e' e : idempotent_cri A) : ( e' = e ) ↔ (↑e' : A) = ↑e :=
begin
  split,
  -- ->
  intros hz,
  let gg := congr_arg subtype.val hz, 
  exact gg,
  -- <-
  intros hz,
  -- exact subtype.eq hz,
  apply subtype.eq,
  exact hz,
end

-- Some coercian lemmas:
lemma coe_eq_val (e : idempotent_cri A) : (↑e : A) = e.val :=
begin
  refl,
end

lemma coe_eq_val' (e : idempotent_cri A) : e.val = ↑e :=
begin
  refl,
end

lemma val_of' {A : Type*} [comm_ring A] (v : A) (h : v * v = v)
 : ↑(⟨ v, h ⟩ : idempotent_cri A) = v :=
begin
  refl,
end

lemma val_of_cri {A : Type*} [comm_ring A] (e : idempotent_cri A)
 : ↑(⟨ e.val, e.property ⟩ : idempotent_cri A) = e.val :=
begin
  refl,
end

lemma coe_inf' {A : Type*} [comm_ring A] (e e': idempotent_cri A)
(p : (e.val * e'.val) * (e.val * e'.val) = e.val * e'.val)
 : (e ⊓ e' : idempotent_cri A) = ⟨ e.val * e'.val, p ⟩ :=
begin
  refl,
end

lemma ideal_of_idempotent_strictly_increasing {A : Type*} [comm_ring A] 
{e' e : idempotent_cri A} (hlt : e' < e)
: (ideal.span {e'.val} : ideal A) < (ideal.span {e.val} : ideal A) :=
begin
  let pe' := e'.property'', -- e'.val * e'.val = e'.val
  let pe := e.property'', -- e.val * e.val = e.val
  --unfold has_
  have h_lt_e : e'.val * e.val = e'.val, by exact (le_of_lt hlt),
  let hne := ne_of_lt hlt, -- e' ≠ e
  have h_ne_e : e'.val ≠ e.val, 
  begin
    by_contradiction,
    rw (subtype.eq h) at hne,
    contradiction,
  end,
  exact ideal_gt_of_orthog_sum pe' pe h_lt_e h_ne_e,
end

lemma monotone_of_strict_mono {B : Type*} [hB : boolean_algebra B] {K : Type*} {f : ℕ → B}
(h_strict : strict_mono f)
: monotone f :=
begin
  unfold strict_mono at h_strict,
  unfold monotone,
  intros a b h_le,
  have lt_or_eq : a < b ∨ a = b, by exact lt_or_eq_of_le h_le,
  cases lt_or_eq,
  -- lt_or_eq: a < b
  exact le_of_lt (h_strict lt_or_eq),
  -- lt_or_eq: a = b
  apply le_of_eq,
  rw lt_or_eq,
end

lemma not_strict_mono_of_stabilizing_sequence {B : Type*} [hB : partial_order B] 
{f : ℕ → B} {stabilizes : ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → f n = f m}
: ¬ strict_mono f :=
begin
  unfold strict_mono, 
  by_contradiction h_strict_mono,
  cases stabilizes with k stabilizes',
  let h_stab := stabilizes' k.succ (nat.le_succ k),
  let h_strict := @h_strict_mono k k.succ (lt_add_one k),
  rw h_stab at h_strict, 
  let h_contra := ne_of_lt h_strict,
  contradiction,
end

def order_hom_of_str {B : Type*} [hB : partial_order B] {f : ℕ → B} (h_strict_mono : strict_mono f) :
ℕ →o B :=
begin
  have h_monotone : monotone f,
  begin
    unfold monotone, 
    intros a b h_le,
    unfold strict_mono at h_strict_mono,
    have eq_or_lt : a = b ∨ a < b, by exact eq_or_lt_of_le h_le,
    cases eq_or_lt,
    -- a = b
    rw eq_or_lt,
    -- a < b
    let fa_lt_fb := @h_strict_mono a b eq_or_lt,
    exact le_of_lt fa_lt_fb,
  end,
  exact { to_fun := f, monotone' := h_monotone },
end

lemma helper {K : Type*} [field K] {A : Type*} [comm_ring A] [algebra K A] 
(g : ℕ → submodule K A) (g_strict: ∀ ⦃a b : ℕ⦄, a < b → g a < g b)
(g_stab: ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → g n = g m ) : false :=
begin
  cases g_stab with n g_stab',
  let g_stab'' := g_stab' n.succ (nat.le_succ n), -- g.to_fun n = g.to_fun n.succ
  let g_strict' := g_strict (lt_add_one n),
  rw g_stab'' at g_strict',
  let h_ne := ne_of_lt g_strict',
  simp at h_ne, -- false
  contradiction,
end

-- When the K-algebra is finite dimensional then there does not exist
-- a strictly increasing sequence of ideals.
theorem no_strict_mono_to_ideals_from_finite_dimensional (K : Type*) 
[hK : field K] {A : Type*} 
  [h_comm_A : comm_ring A] [h_alg : algebra K A] (h_fin : finite_dimensional K A) :
( ¬( ∃ (strict_mono_seq : ℕ → ideal A), strict_mono strict_mono_seq ) ) :=
begin
  rw finite_dimensional at h_fin, --  module.finite K A
  rw ← is_noetherian.iff_fg at h_fin, -- is_noetherian K A
  rw ← monotone_stabilizes_iff_noetherian at h_fin, 
    -- ∀ (f : ℕ →o submodule K A), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m
  by_contradiction h_ex_strict_mono', -- By contradiction we get a strictly monotone sequence of ideals
  -- From this we a strictly monotone sequence of submodules:
  cases h_ex_strict_mono' with f f_strict,
  have ex_strict_mono_submodule :  ∃ (g : ℕ → submodule K A), strict_mono g, 
  by exact ex_strict_mono_submodule_of_ideal f f_strict,
  cases ex_strict_mono_submodule with g g_strict,
  unfold strict_mono at g_strict,
  let g_stab := h_fin (order_hom_of_str g_strict),
  let dd := helper g g_strict g_stab,
  assumption,
end

def ideal_of_idempotent  
(A : Type*) [h_comm_A : comm_ring A] : idempotent_cri A → ideal A :=
λ (e : idempotent_cri A), ideal.span {e.val}

lemma  ideal_of_idempotent_stric_mono (A : Type*) [comm_ring A] 
: strict_mono (ideal_of_idempotent A) :=
begin
  unfold strict_mono,
  intros e' e hlt,
  exact ideal_of_idempotent_strictly_increasing hlt,
end

theorem strict_mono_to_ideals_of_strict_mono_to_idempotent 
{A : Type*} [h_comm_A : comm_ring A] 
(ex_strict_mono_to_idempotent : ∃ (strict_mono_seq : ℕ → (idempotent_cri A)), strict_mono strict_mono_seq) :
∃ (f : ℕ → ideal A), strict_mono f :=
begin
  cases ex_strict_mono_to_idempotent with f f_strict,
  use (ideal_of_idempotent A ) ∘ f,
  exact strict_mono.comp (ideal_of_idempotent_stric_mono A ) f_strict,
end

theorem no_strict_mono_to_idempotents_from_finite_dimensional (K : Type*) 
[hK : field K] {A : Type*} 
  [h_comm_A : comm_ring A] [h_alg : algebra K A] (h_fin : finite_dimensional K A) :
( ¬( ∃ (strict_mono_seq : ℕ → idempotent_cri A), strict_mono strict_mono_seq ) ) :=
begin
  by_contradiction ex_strict_mono,
  let ex_strict_mono_to_ideals := 
  @strict_mono_to_ideals_of_strict_mono_to_idempotent A h_comm_A ex_strict_mono,
  let no_strict_mono_ideals := 
  @no_strict_mono_to_ideals_from_finite_dimensional K hK A h_comm_A h_alg h_fin,
  contradiction,
end

-- The main theorem states that a finite dimensional algebra has a 
-- finite set of atoms with sup = ⊤:
theorem ex_fin_atomset_of_finite_dimensional (K : Type*) 
[hK : field K] {A : Type*} 
  [h_comm_A : comm_ring A] [h_alg : algebra K A] (h_fin : finite_dimensional K A) : 
∃ (s : finset (idempotent_cri A)), (∀ e ∈ s, ⊥ ⋖ e) ∧ boolean_algebra_finset_sup s = ⊤ :=
begin
  let no_strict_mono_to_idempotents := 
  @no_strict_mono_to_idempotents_from_finite_dimensional K hK A h_comm_A h_alg h_fin,
  exact exists_fin_atomset_sup_top_of_not_strict_mono no_strict_mono_to_idempotents,
end

end convert_cri

lemma not_top_from_coatom {A : Type*} [comm_ring A] {e : A} 
(hcov : covers_0 e) 
: (1 : A) ∉ (ideal.span {1 - e} : ideal A) :=
begin
  cases hcov with he_nz h, cases h with he_idem he'_covby_e,
  
  have h_no_inv : ∀ (a : A), a * (1 - e) ≠ 1,
  begin
    by_contradiction h_contra,
    push_neg at h_contra, cases h_contra with a h_contra,
    have hc : e * (a * (1 - e)) = a * (e - e * e), by ring,
    rw h_contra at hc, rw mul_one at hc, rw he_idem at hc,
    have hc1 : a * (e - e) = 0, by ring,
    rw hc1 at hc,
    contradiction,
  end,
  have h : is_unit (1 - e : A) ↔ (∃ (b : A), (1 - e) * b = 1), by exact is_unit_iff_exists_inv,
  have hn : (∀ (b : A), b * (1 - e) ≠ 1) → ¬is_unit (1 - e : A),
  begin
    contrapose, push_neg, rw h, intros hh, 
    cases hh with a hh, use a, rw mul_comm, assumption,
  end,
  specialize hn h_no_inv, -- ¬is_unit (1 - e)
  rw ← ideal.span_singleton_eq_top at hn, -- ¬ideal.span {1 - e} = ⊤
  rw ← ideal.eq_top_iff_one, assumption,
end

lemma maxideal_from_atom {A : Type*} [comm_ring A] {e : A} 
(hcov : covers_0 e) (h_inv : all_rel_inv A)  : 
(ideal.span {1 - e} : ideal A).is_maximal :=
begin
  unfold all_rel_inv at h_inv, unfold is_rel_inv at h_inv,
  let I := (ideal.span {1 - e} : ideal A),
  have h1me_in_I : (1 - e) ∈ I, by exact submodule.mem_span_singleton_self (1 - e),
  have hJtop : (∀ (J : ideal A) (a : A), I ≤ J → a ∉ I → a ∈ J → (1 : A) ∈ J) :=
  begin
    intros J a hIleJ ha_nin_I ha_in_J,
    have hIssJ : ↑I ⊆ ↑J ↔ I ≤ J, by exact set_like.coe_subset_coe,
    rw ← hIssJ at hIleJ, -- ↑I ⊆ ↑J
    rw set.subset_def at hIleJ, -- ∀ (x : A), x ∈ ↑I → x ∈ ↑J
    specialize hIleJ (1 - e),
    have h1me_in_J : 1 - e ∈ J, by exact hIleJ h1me_in_I,
    have hnI : a * (1-e) ≠ a, 
    begin
      by_contradiction,
      have h1 : a * (1 - e) ∈ I, by exact ideal.mul_mem_left I (a : A) h1me_in_I, 
      rw h at h1,
      contradiction,
    end,
    have hexb : ∃ b, b * a = e , by exact maxideal_from_atom' hcov h_inv hnI,
    cases hexb with b hbae,
    have hba_in_J : b * a ∈ J, by exact ideal.mul_mem_left J b ha_in_J,
    rw hbae at hba_in_J, -- e ∈ J
    have he1me_in_J : e + (1 - e) ∈ J, by exact ideal.add_mem J hba_in_J h1me_in_J,
    have h1eqe1me : 1 = e + (1 - e), by ring,
    rw h1eqe1me, assumption,
  end,
  have h1_nin_I : (1 : A) ∉ I, by exact not_top_from_coatom hcov,
  have hImax : (1 : A) ∉ I ∧ (∀ (J : ideal A) (a : A), I ≤ J → a ∉ I → a ∈ J → (1 : A) ∈ J),
  by exact and.intro h1_nin_I hJtop,
  rw ← ideal.is_maximal_iff at hImax,
  assumption,
end

lemma ae_eq_a_of_a_in_ideal_span_e {A : Type*} [comm_ring A]  (h_inv : all_rel_inv A)
{e a : A} (hcov : covers_0 e) (ha : a ∈ ((ideal.span {e} : ideal A)) ) : 
a * e = a :=
begin
  have hb : ∃ a' : A, a' * e = a, by exact ideal.mem_span_singleton'.mp ha,
  cases hb with a' a'e,
  rw ← a'e,
  rw mul_assoc,
  cases hcov with h h1, cases h1 with h_idempotent h1, 
  rw h_idempotent,
end

lemma ae_in_span {A : Type*} [comm_ring A] 
{e a : A} :  a * e ∈ ((ideal.span {e} : ideal A))  :=
begin
  rw ideal.mem_span_singleton,
  unfold has_dvd.dvd, use a, rw mul_comm,
end

def to_cri {A : Type*} [hA : comm_ring A] {a : A} (h : a * a = a) : idempotent_cri A :=
 ⟨ a, h ⟩

lemma to_cri_eq {A : Type*} [hA : comm_ring A] {a : A} (h : a * a = a) :
(to_cri h).property = h := 
begin
  unfold to_cri,
end

def to_cri_covers0 {A : Type*} [hA : comm_ring A] {a : A} (h : covers_0 a) : 
idempotent_cri A :=
begin
  unfold covers_0 at h,
  cases h with hnz_a h, cases h with ha h,
  exact to_cri ha,
end

lemma covers0_le {A : Type*} [hA : comm_ring A] {a e: A} (h : covers_0 e) 
(ha : a * a = a) (haea : a * e = a): 
a = 0 ∨ a = e :=
begin 
  unfold covers_0 at h,
  cases h with hnz h1, cases h1 with he h2,
  exact h2 a ha haea, 
end

lemma field_from_atom {A : Type*} [hA : comm_ring A]  (h_inv : all_rel_inv A)
{e a : A} (hnz_a : a ≠ 0) (hcov : covers_0 e) (ha_in_span : a ∈ ((ideal.span {e} : ideal A)) ) : 
 a * e = a ∧ 
 ( ∃ (b : A), b ∈ ((ideal.span {e} : ideal A)) ∧ a * b = e) :=
begin
  split,
  -- goal : a * e = a
  exact @ae_eq_a_of_a_in_ideal_span_e A hA h_inv e a hcov ha_in_span,
  -- ∃ (b : A), b ∈ ideal.span {e} ∧ a * b = e
  unfold all_rel_inv at h_inv,
  have  hex_rel : ∃ (b : A), is_rel_inv a b, by exact h_inv a,
  cases hex_rel with b h_rel_inv,
  unfold is_rel_inv at h_rel_inv,
  cases h_rel_inv with he' h, cases h with ha hb,
  have haea : a * e = a, by exact ae_eq_a_of_a_in_ideal_span_e h_inv hcov ha_in_span,
  have hae : (a * e) * e = a * e,
  begin
    rw haea, exact haea,
  end,
  have habe_ab : a * b * e = a * b,
  begin
    conv {to_rhs, rw ← haea}, ring,
  end,
  have hab_0_or_e : a * b = 0 ∨ a * b = e, by exact covers0_le hcov he' habe_ab,
  use b * e, 
  split,
  -- goal : b * e e ∈ ideal.span {e}
  exact ae_in_span,
  -- a * (b * e) = e
  have hnz_ab : a * b ≠ 0,
  begin
    by_contradiction,
    rw h at ha, simp at ha, -- 0 = a,
    rw ha at hnz_a,
    contradiction,
  end,
  cases hab_0_or_e,
  contradiction,
  -- goal a * (b * e) = e
  rw ← mul_assoc,
  rw hab_0_or_e,
  unfold covers_0 at hcov,
  cases hcov with h1 h2, cases h2 with he h3,
  exact he,
end

end inv_a
