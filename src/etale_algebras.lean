/-
Copyright (c) 2022 Flemming Hermansen. 
Released under Apache 2.0 license as described in 
https://www.apache.org/licenses/LICENSE-2.0
Authors: Flemming Hermansen
-/

import data.polynomial.basic
import data.polynomial.eval
import tactic
import tactic.basic
import ring_theory.algebraic
import ring_theory.ideal.quotient
import field_theory.separable
import field_theory.minpoly
import field_theory.splitting_field
import algebra.algebra.basic
import algebra.algebra.subalgebra.basic
import algebra.algebra.tower
import algebra.ring.basic
import data.finset.basic
import algebra.big_operators.basic

import ideals_rel_inv

variables {K : Type*} [hK : field K] 
{A : Type*} [hA : comm_ring A] [h_alg : algebra K A] 
  [h_fin : finite_dimensional K A] [h_sep : is_separable K A] (P : polynomial K)
 {finprod_fields : Type*} [hF : comm_ring finprod_fields] [h_alg_f : algebra K finprod_fields]
------------------
universes u 

def Ka {K : Type*} {A : Type*} [hK : field K] 
 [hA : comm_ring A] [h_alg : algebra K A] (a: A) := 
 -- The problem is that a field (hK) is not accepted.
 -- An explicit comm_ring is required.
algebra.adjoin K ({a} : set A)

/- -- Remove this line in order to see the errors
-- Lean can not convert properly between fields and commutaative semirings.
-- The unfold should work, but it is confused about these types:
noncomputable
lemma Ka_eqv' {K : Type*} [hK : field K] 
{A : Type*} [hA : comm_ring A] [h_alg : algebra K A] (a : A) 
[h_fin : finite_dimensional K A] [h_sep : is_separable K A]: 
((@Ka K A hK hA h_alg a) : subalgebra K A ) ≃ₐ[K] 
(polynomial K ⧸ (ideal.span {minpoly K a} : ideal (polynomial K))) := 
begin
  -- Does not work: 
  unfold Ka,
  sorry
end

@[priority 100] 
instance field.to_comm_semiring' [s : field K] : comm_semiring K :=
{ mul_zero := mul_zero, zero_mul := zero_mul, ..s }

def Ka' {K : Type*} {A : Type*} [hK : field K] 
 [hA : comm_ring A] [h_alg : algebra K A] (a: A) := 
 -- Does not work: 
 @algebra.adjoin K A hK hA h_alg ({a} : set A).
 -- The problem is that a field (hK) is not accepted.
 -- An explicit comm_ring is required.

#check Ka.
#check adjoin_root.
#check algebra.adjoin.
-- -/


noncomputable
lemma Ka_eqv {K : Type*} [hK : field K] 
{A : Type*} [hA : comm_ring A] [h_alg : algebra K A] 
(a : A) :
algebra.adjoin K ({a} : set A) ≃ₐ[K] 
(polynomial K ⧸ (ideal.span {minpoly K a} : ideal (polynomial K))) := 
begin
  exact @alg_equiv.adjoin_singleton_equiv_adjoin_root_minpoly K hK A hA h_alg a,
end

/-
We have the following lemmas:

lemma Ka_eqv {K : Type*} [hK : field K] 
{A : Type*} [hA : comm_ring A] [h_alg : algebra K A] 
(a : A) :
algebra.adjoin K ({a} : set A) ≃ₐ[K] 
(polynomial K ⧸ (ideal.span {minpoly K a} : ideal (polynomial K))) 

lemma product_all_rel_inv {A : Type*} [comm_semigroup A] {A' : Type*} [comm_semigroup A']  
  : ( all_rel_inv A) → ( all_rel_inv A')  → all_rel_inv (A × A')

lemma field_all_rel_inv {A : Type} [field A] : all_rel_inv A

noncomputable def ideal.quotient_inf_ring_equiv_pi_quotient {R : Type*} [comm_ring R] 
 {ι : Type v} [finite ι] (f : ι → ideal R) (hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤) :
(R ⧸ ⨅ (i : ι), f i) ≃+* Π (i : ι), R ⧸ f i

We could however not combine these lemmas, because of errors in Lean. 

Therefore, we will just state the following lemma

lemma from_chinese_lemma {K : Type*} [hK : field K] 
{A : Type*} [hA : comm_ring A] [h_alg : algebra K A]
(h_sep : is_separable K A)
(a : A) (h_algebraic : is_algebraic K a)
: ∃ (b : A), is_rel_inv a b
-/

lemma from_chinese_lemma {K : Type*} [hK : field K] 
{A : Type*} [hA : comm_ring A] [h_alg : algebra K A]
(h_sep : is_separable K A) (h_algebraic : algebra.is_algebraic K A)
(a : A) 
: ∃ (b : A), is_rel_inv a b :=
begin
  sorry
end

lemma all_rel_inv_of_alg_sep {K : Type*} [hK : field K] 
{A : Type*} [hA : comm_ring A] [h_alg : algebra K A]
(h_sep : is_separable K A) (h_algebraic : algebra.is_algebraic K A) :
all_rel_inv A :=
begin
  unfold all_rel_inv,
  intros a,
  exact from_chinese_lemma h_sep h_algebraic a,
end

/-
We have proved the following theorems:
This theorem states that if e is an atom then e is the one-element in the ideal,
and each non-zero element in the ideal has an inverse within the ideal. 
This means that an ideal generated by an atom is a field.
lemma field_from_atom {A : Type*} [hA : comm_ring A]  (h_inv : all_rel_inv A)
{e a : A} (hnz_a : a ≠ 0) (hcov : covers_0 e) (ha_in_span : a ∈ ((ideal.span {e} : ideal A)) ) : 
a * e = a ∧ 
( ∃ (b : A), b ∈ ((ideal.span {e} : ideal A)) ∧ a * b = e)

-- This theorem states that a finite dimensional algebra has a 
-- finite set of atoms with sup = ⊤:
theorem ex_fin_atomset_of_finite_dimensional (K : Type*) 
[hK : field K] {A : Type*} 
  [h_comm_A : comm_ring A] [h_alg : algebra K A] (h_fin : finite_dimensional K A) : 
∃ (s : finset (idempotent_cri A)), (∀ e ∈ s, ⊥ ⋖ e) ∧ boolean_algebra_finset_sup s = ⊤ 

Atoms are pairwise disjoint. Therefore, boolean_algebra_finset_sup s = ⊤ means
that their sum is 1. 

We have the direct sum decomposition of elements (a:A): a = a * 1 = a * Σ a * ei,
where ei are the atoms. This decomposition is unique, because ei ≠ ej implies ei * ej = 0.
This means that A = Π (ideal generated by ei).
Each of these ideals are isomorphic to field extensions of the scalar field.

This means that a finite dimensional separable commutative unital algebra is an
Etale algebra.
-/
